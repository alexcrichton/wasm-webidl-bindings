use crate::actions::Actions;
use std::str::FromStr;

grammar<A>(actions: &mut A)
    where A: Actions;

pub WebidlBindingsSection: A::WebidlBindingsSection =
    <types:WebidlTypeSubsection> <bindings:WebidlFunctionBindingsSubsection> =>
        actions.webidl_bindings_section(types, bindings);

WebidlTypeSubsection: A::WebidlTypeSubsection =
    <types:WebidlType*> => types.into();

pub(crate) WebidlType: A::WebidlType =
    "type" <name:Identifier?> <ty:WebidlCompoundType> =>
        actions.webidl_type(name, ty);

WebidlCompoundType: A::WebidlCompoundType = {
    <a:WebidlFunction> => a.into(),
    // <a:WebidlCompoundTypeDictionary> => a.into(),
    // <a:WebidlCompoundTypeEnumeration> => a.into(),
    // <a:WebidlCompoundTypeUnion> => a.into(),
};

WebidlFunction: A::WebidlFunction = {
    "("
        "func"
        <kind:WebidlFunctionKind?>
        <params:WebidlFunctionParams?>
        <result:WebidlFunctionResult?>
    ")" => actions.webidl_function(kind, params, result),
};

WebidlFunctionKind: A::WebidlFunctionKind = {
    <a:WebidlFunctionKindMethod> => a.into(),
    <a:WebidlFunctionKindConstructor> => a.into(),
    // NB: functions that lack a kind are implicitly static.
};

WebidlFunctionKindMethod: A::WebidlFunctionKindMethod =
    "(" "method" <ty:WebidlTypeRef> ")" =>
        actions.webidl_function_kind_method(ty);

WebidlFunctionKindConstructor: A::WebidlFunctionKindConstructor = {
    "(" "constructor" "default-new-target" ")" =>
        actions.webidl_function_kind_constructor_default_new_target(),
    // TODO: What are the non-default target forms?
};

WebidlFunctionParams: A::WebidlFunctionParams =
    "(" "param" <tys:WebidlTypeRef*> ")" =>
        actions.webidl_function_params(tys);

WebidlFunctionResult: A::WebidlFunctionResult =
    "(" "result" <ty:WebidlTypeRef> ")" =>
        actions.webidl_function_result(ty);

WebidlFunctionBindingsSubsection: A::WebidlFunctionBindingsSubsection =
    <bindings:FunctionBinding*> => bindings.into();

FunctionBinding: A::FunctionBinding = {
    "TODO-FUNCTION-BINDING" => unimplemented!(),
    // <a:ImportBinding> => a.into(),
    // <a:ExportBinding> => a.into(),
};

pub(crate) WebidlTypeRef: A::WebidlTypeRef = {
    <a:WebidlTypeRefNamed> => a.into(),
    <a:WebidlTypeRefIndexed> => a.into(),
};

WebidlTypeRefNamed: A::WebidlTypeRefNamed =
    <s:Identifier> =>
        actions.webidl_type_ref_named(s);

WebidlTypeRefIndexed: A::WebidlTypeRefIndexed =
    <idx: Unsigned> =>
        actions.webidl_type_ref_indexed(idx);

pub(crate) WasmTypeRef: A::WasmTypeRef = {
    <a:WasmTypeRefNamed> => a.into(),
    <a:WasmTypeRefIndexed> => a.into(),
};

WasmTypeRefNamed: A::WasmTypeRefNamed =
    <s:Identifier> =>
        actions.wasm_type_ref_named(s);

WasmTypeRefIndexed: A::WasmTypeRefIndexed =
    <idx: Unsigned> =>
        actions.wasm_type_ref_indexed(idx);

pub(crate) ExportBindingRef: A::ExportBindingRef = {
    <a:ExportBindingRefNamed> => a.into(),
    <a:ExportBindingRefIndexed> => a.into(),
};

ExportBindingRefNamed: A::ExportBindingRefNamed =
    <s:Identifier> =>
        actions.export_binding_ref_named(s);

ExportBindingRefIndexed: A::ExportBindingRefIndexed =
    <idx: Unsigned> =>
        actions.export_binding_ref_indexed(idx);

pub(crate) ImportBindingRef: A::ImportBindingRef = {
    <a:ImportBindingRefNamed> => a.into(),
    <a:ImportBindingRefIndexed> => a.into(),
};

ImportBindingRefNamed: A::ImportBindingRefNamed =
    <s:Identifier> =>
        actions.import_binding_ref_named(s);

ImportBindingRefIndexed: A::ImportBindingRefIndexed =
    <idx: Unsigned> =>
        actions.import_binding_ref_indexed(idx);

pub OutgoingBindingExpression: A::OutgoingBindingExpression = {
    <a:OutgoingBindingExpressionAs> => a.into(),
    <a:OutgoingBindingExpressionUtf8Str> => a.into(),
    <a:OutgoingBindingExpressionUtf8CStr> => a.into(),
    <a:OutgoingBindingExpressionI32ToEnum> => a.into(),
    <a:OutgoingBindingExpressionView> => a.into(),
    <a:OutgoingBindingExpressionCopy> => a.into(),
    <a:OutgoingBindingExpressionDict> => a.into(),
    <a:OutgoingBindingExpressionBindExport> => a.into(),
};

OutgoingBindingExpressionAs: A::OutgoingBindingExpressionAs =
    "(" "as" <ty:WebidlTypeRef> <idx:Unsigned> ")" =>
        actions.outgoing_binding_expression_as(ty, idx);

OutgoingBindingExpressionUtf8Str: A::OutgoingBindingExpressionUtf8Str =
    "(" "utf8-str" <ty:WebidlTypeRef> <offset:Unsigned> <length:Unsigned> ")" =>
        actions.outgoing_binding_expression_utf8_str(ty, offset, length);

OutgoingBindingExpressionUtf8CStr: A::OutgoingBindingExpressionUtf8CStr =
    "(" "utf8-cstr" <ty:WebidlTypeRef> <offset:Unsigned> ")" =>
        actions.outgoing_binding_expression_utf8_c_str(ty, offset);

OutgoingBindingExpressionI32ToEnum: A::OutgoingBindingExpressionI32ToEnum =
    "(" "i32-to-enum" <ty:WebidlTypeRef> <idx:Unsigned> ")" =>
        actions.outgoing_binding_expression_i32_to_enum(ty, idx);

OutgoingBindingExpressionView: A::OutgoingBindingExpressionView =
    "(" "view" <ty:WebidlTypeRef> <offset:Unsigned> <length:Unsigned> ")" =>
        actions.outgoing_binding_expression_view(ty, offset, length);

OutgoingBindingExpressionCopy: A::OutgoingBindingExpressionCopy =
    "(" "copy" <ty:WebidlTypeRef> <offset:Unsigned> <length:Unsigned> ")" =>
        actions.outgoing_binding_expression_copy(ty, offset, length);

OutgoingBindingExpressionDict: A::OutgoingBindingExpressionDict =
    "(" "dict" <ty:WebidlTypeRef> <fields:OutgoingBindingExpression*> ")" =>
        actions.outgoing_binding_expression_dict(ty, fields);

OutgoingBindingExpressionBindExport: A::OutgoingBindingExpressionBindExport =
    "(" "bind-export" <ty:WebidlTypeRef> <binding:ExportBindingRef> <idx:Unsigned> ")" =>
        actions.outgoing_binding_expression_bind_export(ty, binding, idx);

pub IncomingBindingExpression: A::IncomingBindingExpression = {
    <a:IncomingBindingExpressionGet> => a.into(),
    <a:IncomingBindingExpressionAs> => a.into(),
    <a:IncomingBindingExpressionAllocUtf8Str> => a.into(),
    <a:IncomingBindingExpressionAllocCopy> => a.into(),
    <a:IncomingBindingExpressionEnumToI32> => a.into(),
    <a:IncomingBindingExpressionField> => a.into(),
    <a:IncomingBindingExpressionBindImport> => a.into(),
};

IncomingBindingExpressionGet: A::IncomingBindingExpressionGet =
    "(" "get" <idx:Unsigned> ")" =>
        actions.incoming_binding_expression_get(idx);

IncomingBindingExpressionAs: A::IncomingBindingExpressionAs =
    "(" "as" <ty:WasmTypeRef> <expr:IncomingBindingExpression> ")" =>
        actions.incoming_binding_expression_as(ty, expr);

IncomingBindingExpressionAllocUtf8Str: A::IncomingBindingExpressionAllocUtf8Str =
    "("
        "alloc-utf8-str"
        <alloc_func_name:Identifier>
        <expr:IncomingBindingExpression>
    ")" =>
        actions.incoming_binding_expression_alloc_utf8_str(alloc_func_name, expr);

IncomingBindingExpressionAllocCopy: A::IncomingBindingExpressionAllocCopy =
    "("
        "alloc-copy"
        <alloc_func_name:Identifier>
        <expr:IncomingBindingExpression>
    ")" =>
        actions.incoming_binding_expression_alloc_copy(alloc_func_name, expr);

IncomingBindingExpressionEnumToI32: A::IncomingBindingExpressionEnumToI32 =
    "(" "enum-to-i32" <ty:WebidlTypeRef> <expr:IncomingBindingExpression> ")" =>
        actions.incoming_binding_expression_enum_to_i32(ty, expr);

IncomingBindingExpressionField: A::IncomingBindingExpressionField =
    "(" "field" <idx:Unsigned> <expr:IncomingBindingExpression> ")" =>
        actions.incoming_binding_expression_field(idx, expr);

IncomingBindingExpressionBindImport: A::IncomingBindingExpressionBindImport =
    "(" "bind-import" <ty:WasmTypeRef> <binding:ImportBindingRef> <expr:IncomingBindingExpression> ")" =>
        actions.incoming_binding_expression_bind_import(ty, binding, expr);

Unsigned: u32 = <s:r"[0-9]+"> => u32::from_str(s).unwrap();

Identifier: &'input str = <r"[a-zA-Z$][a-zA-Z0-9$_]*">;
